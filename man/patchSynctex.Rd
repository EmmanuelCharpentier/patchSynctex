\name{patchSynctex}
\alias{patchSynctex}
\title{Create correspondence between .pdf and .Rnw files}

\description{
\code{patchSynctex(foo)} uses the concordance file
\code{foo-concordance.tex} generated by \code{knit}ting (possibly
\code{Sweave}ing) \code{foo.Rnw} with the option \code{concordance=TRUE}
 to patch \code{foo.synctex(.gz)} with information pointing to
\code{foo.Rnw}.
}

\usage{
patchSynctex(nwfile, verbose=FALSE, ...)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{nwfile}{ name of the file to patch (used sans extension).  }
  \item{verbose}{ if TRUE, emit a message stating the number of
    patches. }
  \item{\dots}{
    Unused. Allows \code{.ess_sweave} to pass its beloved
    \code{encoding="utf8"} option without causing an error.
  }
}

\details{

  This function reads the information given in the
  \code{nwfile-concordance.tex} file (which \emph{must} exist) to patch
  the \code{nwfile.synctex(.gz)} file, which originally contains
  pointers from \code{nwfile.pdf} to the source in \code{nwfile.tex}
  with information pointing to the latter's source in \code{nwfile.Rnw}.

  Editors and viewers supporting Synctex will be able to use this
  information to allow forward- and backward search between PDF and ists
  original source, thus easing debugging.
  
  The \code{nwfile} will be used sans extension ; this allows your
  favorite IDE to pass either the name of the noweb file or the name of
  the .tex file.

  The function may raise errors (files not found), warnings (no patch
  found to be done) or messages (number of patched locations.

  This function is principally intended for use by programmable IDEs able
  to execute \code{R} code. It is documented mostly for debugging
  purposes.

}

\value{Nothing useful.}
%%  ~Describe the value returned
%%  If it is a LIST, use
%%  \item{comp1 }{Description of 'comp1'}
%%  \item{comp2 }{Description of 'comp2'}
%% ...

\references{
Duncan Murdoch's excellent \code{patchDVI} package:
  \url{http://CRAN.R-project.org/package=patchDVI}. 
}

\author{Jan Gleixner, Emmanuel Charpentier \email{emm.charpentier@free.fr}}
%% \note{
%% %%  ~~further notes~~
%% }

%% %% ~Make other sections like Warning with \section{Warning }{....} ~

%% \seealso{
%% %% ~~objects to See Also as \code{\link{help}}, ~~~
%% }
%% \examples{
%% ##---- Should be DIRECTLY executable !! ----
%% ##-- ==>  Define data, use random,
%% ##--	or do  help(data=index)  for the standard data sets.

%% ## The function is currently defined as
%% function (texfile, ...) 
%% {
%%     require(tools)
%%     f = paste0(tools::file_path_sans_ext(texfile), "-concordance.tex")
%%     if (!file.exists(f)) 
%%         stop(paste(f, "does not exist! Did you set 'opts_knit$set(concordance = TRUE);'?"))
%%     text <- readChar(f, file.info(f)$size)
%%     text <- gsub(" \\\%\\n", " ", text)
%%     require(stringr)
%%     re = "\\\\Sconcordance\\{concordance:([^:]*):([^\\\%]*):\\\%\\r?\\n(\\d+)(( \\d+ \\d+)*)\\}"
%%     parsed = str_match_all(text, re)
%%     for (i in seq(1, nrow(parsed[[1]]))) {
%%         texF = parsed[[1]][i, 2]
%%         rnwF = parsed[[1]][i, 3]
%%         startLine = as.integer(parsed[[1]][i, 4])
%%         rleValues <- read.table(textConnection(parsed[[1]][i, 
%%             5]))
%%         rleO = rle(0)
%%         rleO$values = as.numeric(rleValues[seq(2, length(rleValues), 
%%             2)])
%%         rleO$lengths = as.integer(rleValues[seq(1, length(rleValues), 
%%             2)])
%%         diffs = inverse.rle(rleO)
%%         mapping_ = c(startLine, startLine + cumsum(diffs[-1]))
%%         basename <- tools::file_path_sans_ext(rnwF)
%%         syncF = paste0(basename, ".synctex")
%%         compressed <- FALSE
%%         if (file.exists(syncF)) {
%%             sf = file(syncF)
%%         }
%%         else {
%%             syncF <- paste(syncF, ".gz", sep = "")
%%             if (file.exists(syncF)) {
%%                 compressed <- TRUE
%%                 sf <- gzfile(syncF)
%%             }
%%         }
%%         lines <- try(readLines(syncF, warn = FALSE), silent = TRUE)
%%         if (inherits(lines, "try-error")) 
%%             stop(paste(f, "cannot be read, no patching done."))
%%         close(sf)
%%         postemble = grep("^Postamble:", lines, perl = T)
%%         re = paste0("^Input:([^:]+):(.*", basename(texF), ")")
%%         toRepl = grep(re, lines[seq(1, postemble)], perl = T)
%%         inputs = str_match(lines[toRepl], re)
%%         if (length(inputs) > 0) {
%%             tag = inputs[, 2]
%%             inputs[, 3] = paste0(tools::file_path_sans_ext(inputs[, 
%%                 3]), ".Rnw")
%%             lines[toRepl] = paste0("Input:", inputs[, 2], ":", 
%%                 inputs[, 3])
%%             re = paste0("^([xkgvh\\$\\(\\[]", tag, "\\,)(\\d+)([\\,:].*)")
%%             needReplacment = grep(re, lines[seq(1, postemble)], 
%%                 perl = T)
%%             toRepl = str_match(lines[needReplacment], re)
%%             toRepl[, 3] = as.character(mapping_[as.integer(toRepl[, 
%%                 3])])
%%             newlines = paste0(toRepl[, 2], toRepl[, 3], toRepl[, 
%%                 4])
%%             lines[needReplacment] = newlines
%%             if (!compressed) {
%%                 sf = file(syncF, "wb")
%%             }
%%             else {
%%                 sf <- gzfile(syncF, "wb")
%%             }
%%             writeLines(lines, sf, sep = "\n")
%%             close(sf)
%%             print(paste(length(needReplacment), "patches made to", 
%%                 syncF))
%%         }
%%         else {
%%             print(paste("No patches made to", syncF))
%%         }
%%     }
%%   }
%% }

% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.

\keyword{ ~interface }
\keyword{ ~documentation }% __ONLY ONE__ keyword per line
